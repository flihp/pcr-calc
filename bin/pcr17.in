#!/usr/bin/env python
#
# Copyright 2013 Philip Tricca <flihp@twobit.us>
#

import argparse
import base64
import hashlib
import sys

sys.path.insert(1, '@pythondir@/@PACKAGE@')

import txt

def main():
    description = "Calculate PCR[17] from an Authenticated Code Module (ACM) and whatever data is needed"
    acm_help = "path to ACM file"
    heapfile_help = 'file to read as TXT Heap, /dev/mem is default'
    lcp_help = 'file containing binary Launch Control Policy'
    mmap_help = 'access file through mmap'
    smd_help = "Sinit to Mle Data Table Version.  Default is version 8."
    ver_help = "version information"
    ver_str = "%(prog)s: @PACKAGE@ @VERSION@"

    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('acm', help=acm_help)
    parser.add_argument('-v', '--version', help=ver_help, action='version', version=ver_str)
    parser.add_argument('-i', '--heapfile', help=heapfile_help, default='/dev/mem')
    parser.add_argument('-l', '--lcpfile', help=lcp_help, default=False)
    parser.add_argument('-m', '--mmap', help=mmap_help, action='store_true')
    parser.add_argument('-s', '--smd', default=8, help=smd_help, type=int)
    ns = parser.parse_args()

    f = open (ns.acm, 'rb')
    acm = txt.acmParse (f)

    # Calculate SinitMleData.SinitHash which is the value of PCR[17] after
    #   the first extend operation.
    # See the massively convoluted description in section 1.9.1 of the Intel
    #   MLE Developer's Guide for details.
    # select hash algorithm for ACM based on SINIT to MLE Data Table version
    #   version < 7: sha1 (sha1(ACM) | SinitMleData.EdxSenterFlags)
    #   version > 6: sha1 (sha256 (ACM) | SinitMleData.EdxSenterFlags)
    if ns.smd > 6:
        acmhash = hashlib.sha256 ()
    else:
        acmhash = hashlib.sha1 ()
    acmhash.update (acm.ModuleType_Bytes ())
    acmhash.update (acm.ModuleSubType_Bytes ())
    acmhash.update (acm.HeaderLen_Bytes ())
    acmhash.update (acm.HeaderVersion_Bytes ())
    acmhash.update (acm.ChipsetID_Bytes ())
    acmhash.update (acm.Flags_Bytes ())
    acmhash.update (acm.ModuleVendor_Bytes ())
    acmhash.update (acm.Date_Bytes ())
    acmhash.update (acm.Size_Bytes ())
    acmhash.update (acm.Reserved1_Bytes ())
    acmhash.update (acm.CodeControl_Bytes ())
    acmhash.update (acm.ErrorEntryPoint_Bytes ())
    acmhash.update (acm.GDTLimit_Bytes ())
    acmhash.update (acm.GDTBasePtr_Bytes ())
    acmhash.update (acm.SegSel_Bytes ())
    acmhash.update (acm.EntryPoint_Bytes ())
    acmhash.update (acm.Reserved2 ())
    acmhash.update (acm.KeySize_Bytes ())
    acmhash.update (acm.ScratchSize_Bytes ())
    # These are the fields we don't hash.  See section A.1.2 of the Intel MLE
    #   Developer's Guide for details.
    # acmhash.update (acm.RSAPubKey ())
    # acmhash.update (acm.RSAPubExp_Bytes ())
    # acmhash.update (acm.RSASig ())
    # acmhash.update (acm.Scratch ())
    acmhash.update (acm.UserArea ())

    # Calculate HASH_DATA for first extend of PCR[17]:
    # Assume SinitMleData.EdxSenterFlags is 4 bytes of 0's
    print 'sha256 (acm): {0}'.format (acmhash.hexdigest ())
    hash_data = hashlib.sha1 ()
    hash_data.update (acmhash.digest ())
    hash_data.update (base64.b16decode(b'00000000'))

    # Value of PCR[17] after initial extend = SinitMleData.SinitHash
    #   PCR[17] is initialized to 20 bytes of 0's on platform reset.
    # SinitMleData.SinitHash = sha1 (pcr[17] | HASH_DATA)
    pcr17 = txt.pcrEmu ()
    pcr17.extend (hash_data.digest ())
    print "SinitMleData.SinitHash: {0}".format (pcr17.hexread ())

    dev_mem = False
    if ns.heapfile == '/dev/mem':
        dev_mem = True

    try:
        fd_heapfile = open (ns.heapfile, 'rb')
    except IOError as e:
        sys.stderr.write ('Error opening {0} for reading: \"{1}\" ... Abort\n'.format(e.filename, e.strerror))
        sys.exit (1)

    try:
        if dev_mem:
            txtPubRegs = txt.pubConfRegsParse (fd_heapfile, ns.mmap, dev_mem)
            heap = txt.txtHeap (fd_heapfile, ns.mmap, txtPubRegs.HeapBase (), txtPubRegs.HeapSize ())
        else:
            txtPubRegs = None
            fd_heapfile.seek (0,2)
            file_size = fd_heapfile.tell ()
            fd_heapfile.seek (0)
            heap = txt.txtHeap (fd_heapfile, ns.mmap, 0, file_size)
    except IOError as e:
        sys.stderr.write ('Exception getting TXT Heap: {0}\n'.format (e))
        sys.exit (1)

    sinit_mle = txt.sinitMleData (heap.SinitMleData ())

    print 'sinit_mle.SintHash:'
    for _bytestr in txt.pp_bytearray (sinit_mle.SinitHash ()):
        print "    {0}".format (_bytestr)
    
    # hash stuff from the heap
    extend2 = hashlib.sha1 ()
    print 'append BiosAcmId'
    for _bytestr in txt.pp_bytearray (sinit_mle.BiosAcmId ()):
        print "    {0}".format (_bytestr)
    extend2.update (sinit_mle.BiosAcmId ())
    print 'append MsegValid_Bytes:'
    for _bytestr in txt.pp_bytearray (sinit_mle.MsegValid_Bytes ()):
        print "    {0}".format (_bytestr)
    extend2.update (sinit_mle.MsegValid_Bytes ())
    print 'append StmHash:'
    for _bytestr in txt.pp_bytearray (sinit_mle.StmHash ()):
        print "    {0}".format (_bytestr)
    extend2.update (sinit_mle.StmHash ())
    print 'append PolicyControl_Bytes:'
    for _bytestr in txt.pp_bytearray (sinit_mle.PolicyControl_Bytes ()):
        print "    {0}".format (_bytestr)
    extend2.update (sinit_mle.PolicyControl_Bytes ())
    print 'append LcpPolicyHash:'
    for _bytestr in txt.pp_bytearray (sinit_mle.LcpPolicyHash ()):
        print "    {0}".format (_bytestr)
    extend2.update (sinit_mle.LcpPolicyHash ())

    os_sinit = txt.osSinitData (heap.OsSinitData ())

    print 'append Capabilities_Bytes:'
    for _bytestr in txt.pp_bytearray (os_sinit.Capabilities_Bytes ()):
        print "    {0}".format (_bytestr)
#    extend2.update (os_sinit.Capabilities_Bytes ())
    extend2.update (base64.b16decode ('00000000'))
    if ns.smd >= 8:
        print 'append ProcScrtmStatus_Bytes:'
        for _bytestr in txt.pp_bytearray (sinit_mle.ProcScrtmStatus_Bytes ()):
            print "    {0}".format (_bytestr)
        extend2.update (sinit_mle.ProcScrtmStatus_Bytes ())

    print 'extend2: {0}'.format (extend2.hexdigest ())
    # extend PCR17 with stuff from heap
    pcr17.extend (extend2.digest ())
    print 'PCR[17]: {0}'.format (pcr17.hexread ())
    # extend PCR17 with LCP if 
    if ns.lcpfile:
        try:
            fd_lcp = open (ns.lcpfile, 'rb')
        except IOError as e:
            sys.stderr.write ('Error opening {0} for reading: \"{1}\" ... Abort\n'.format(e.filename, e.strerror))
            sys.exit (1)
    else:
        print 'no LCP file'
        sys.exit (0)

    try:
        lcp_pol = txt.launchCtrlPol (fd_lcp, True)
    except IOError as e:
        sys.stderr.write ('Error mapping LCP ... Abort')
        sys.exit (1)
 
    if lcp_pol.ExtendPCR17 ():
        pol_hash = hashlib.sha1 ()
        pol_hash.update (lcp_pol.Bytes ())
        print 'lcp hash: {0}'.format (pol_hash.hexdigest ())
        polctrl_hash = hashlib.sha1 ()
        polctrl_hash.update (lcp_pol.PolicyControl_Bytes ())
        polctrl_hash.update (pol_hash.digest ())
        print 'polctrl + lcp hash: {0}'.format (polctrl_hash.hexdigest ())
    else:
        print 'PolicyControl says not to extend PCR[17]'

    pcr17.extend (polctrl_hash.digest ())
    print 'PCR[17] final: {0}'.format (pcr17.hexread ())

    sys.exit (0)

if __name__ == "__main__":
    main()
